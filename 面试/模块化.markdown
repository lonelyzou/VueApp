##css模块化
CSS 模块化重要的是要解决好两个问题：CSS 样式的导入和导出。灵活按需导入以便复用代码；导出时要能够隐藏内部作用域，以免造成全局污染。
###css模块化遇到了哪些问题
* 全局污染
* 命名混乱
* 依赖管理不彻底,无法按需导入它所需要的 CSS 样式。
* 代码压缩不彻底,主要体现在非常长的 class 名
###解决
JS 的模块化已经非常成熟，如果能让 JS 来管理 CSS 依赖是很好的解决办法。
Webpack 的 css-loader 提供了这种能力。

`像vue中的<style  scoped>在.vue文件的style标签内配置 scoped`


##js模块化
###全局函数
使用全局函数进行代码的组织，很容易造成功能函数的命名冲突！！
###命名空间
将各项功能函数封装到对象中去。将函数变成对象的属性。
对象名便是此处的命名空间。
使用命名空间是可以解决功能函数命名冲突的。但代码的组织形式还是不容乐观。
###IIFE
使用自执行函数来编写模块化，特点：在一个单独的函数作用域中执行代码，避免变量冲突。


###对前端模块化的认识
* AMD (Asynchronous Module Definition) 即异步模块加载机制, 使用requireJS 来编写模块化，特点：依赖必须提前声明好
* CMD (Common Module Definition)使用seaJS 来编写模块化，特点：支持动态引入依赖文件。
* AMD  是提前执行，CMD 是延迟执行。
* AMD 推荐的风格通过返回一个对象做为模块对象，个文件一个模块, CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的。const Server = require("./app") 方式引入文件
* Common.js 多采用服务端开发， nodejs 中自带的模块化


  
## 4. 请介绍commonjs模块化规范
* commonjs模块化是在nodejs中使用
* 引入其他模块，当前模块使用
  * require(模块路径)
        - 模块路径
          - 自定义模块，模块路径必须加上 ./ 或 ../ ,否则就找不到模块
          - 第三方模块（通过npm工具下载的），模块路径直接就是包名
          - node的核心模块（使用node自带的模块），模块路径直接就是包名
        - 模块名称，文件扩展名   可以省略  .js .json
  * 暴露当前模块的内容，给其他模块使用
     * module.exports 默认值是一个{}  暴露一个内容
     * exports  
      
  * 模块暴露的本质：module.exports指向的值

###CommonJS模块的特点如下
  所有代码都运行在模块作用域，不会污染全局作用域。
  模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
  模块加载的顺序，按照其在代码中出现的顺序。
  
###ES6 模块
ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入
# ES6 模块与 CommonJS 模块的差异
  两个重大差异
  第一个差异
      CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
      CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
      CommonJS 一旦输出一个值，模块内部的变化就影响不到这个值
  第二个差异
      CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成
      ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成
      
